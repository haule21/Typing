name: Publish Release Asset

on:
  push:
    tags:
      - 'v*'

jobs:
  build-and-release:
    runs-on: windows-latest
    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '9.0.x'

      - name: Setup MSBuild
        uses: microsoft/setup-msbuild@v1

      - name: Create and Import Signing Certificate
        id: create_cert
        run: |
          # 1. 인증서 생성 및 저장소 설치
          $pwd = ConvertTo-SecureString -String "TypingAppPassword" -Force -AsPlainText
          $cert = New-SelfSignedCertificate -CertStoreLocation "cert:\CurrentUser\My" `
                    -Subject "CN=TypingApp" `
                    -KeyAlgorithm RSA -KeyLength 2048 `
                    -HashAlgorithm SHA256 -Type CodeSigningCert
          
          # 2. 신뢰할 수 있는 피플 저장소에도 복사 (패키징 승인용)
          $store = New-Object System.Security.Cryptography.X509Certificates.X509Store("TrustedPeople", "CurrentUser")
          $store.Open("ReadWrite")
          $store.Add($cert)
          $store.Close()

          # 3. 인증서 지문(Thumbprint)을 환경 변수로 저장
          echo "CERT_THUMBPRINT=$($cert.Thumbprint)" >> $env:GITHUB_ENV
          Write-Host "✅ Certificate created with Thumbprint: $($cert.Thumbprint)"

      - name: Build and Package MSIX
        run: |
          dotnet publish TypingApp.csproj `
            -c Release `
            -r win-x64 `
            -p:PublishAppxPackage=true `
            -p:AppxPackageSigningEnabled=true `
            -p:PackageCertificateThumbprint="${{ env.CERT_THUMBPRINT }}" `
            -p:AppxPackageDir=".\AppxPackages\" `
            -p:AppxBundle=Always `
            --self-contained false  # 자가 포함 빌드 중단

      - name: Locate and Stage MSIX Files
        run: |
          New-Item -ItemType Directory -Force -Path "FinalOutput"
          
          # 아까 로그에서 확인된 위치까지 포함하여 검색 (Recurse)
          $files = Get-ChildItem -Path . -Recurse -Include *.msix, *.msixbundle, *.appxbundle | Where-Object { $_.FullName -notmatch "obj|FinalOutput" }
          
          if ($files) {
              foreach ($f in $files) {
                  Write-Host "✅ 발견된 패키지: $($f.FullName)"
                  Copy-Item $f.FullName -Destination "FinalOutput"
              }
          } else {
              Write-Error "❌ 패키지 파일을 찾을 수 없습니다."
              exit 1
          }

      # 5. 릴리스 생성 및 업로드
      - name: Create Release and Upload Asset
        uses: softprops/action-gh-release@v1
        if: startsWith(github.ref, 'refs/tags/')
        with:
          # 실제 생성된 .msix 파일과 혹시 모를 bundle 파일을 모두 포함하되, 
          # 없는 파일이 있어도 에러를 내지 않도록 설정합니다.
          files: |
            FinalOutput/*.msix
            FinalOutput/*.msixbundle
            FinalOutput/*.appxbundle
          generate_release_notes: true
          # 이 옵션을 false로 바꿔야 존재하지 않는 확장자 패턴 때문에 실패하지 않습니다.
          fail_on_unmatched_files: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Deploy MSIX to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./FinalOutput
          # destination_dir을 수정하여 태그 버전을 경로에 추가합니다.
          # 예: download/v0.1.0
          destination_dir: download/${{ github.ref_name }}
          # 기존 버전의 파일들을 삭제하지 않고 유지합니다.
          keep_files: true